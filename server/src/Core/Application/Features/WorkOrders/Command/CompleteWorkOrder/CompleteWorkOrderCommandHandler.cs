using Application.Contracts.Logger;
using Application.Contracts.Persistence;
using Application.Exceptions;
using Application.Exceptions.Inventory;

using AutoMapper;

using Domain.Entities;
using Domain.Entities.Enums;
using Domain.Services;

using MediatR;

namespace Application.Features.WorkOrders.Command.CompleteWorkOrder;

public class CompleteWorkOrderCommandHandler : IRequestHandler<CompleteWorkOrderCommand, int>
{
    private readonly IWorkOrderRepository _workOrderRepository;
    private readonly IMaintenanceHistoryRepository _maintenanceHistoryRepository;
    private readonly IInventoryRepository _inventoryRepository;
    private readonly IInventoryTransactionRepository _inventoryTransactionRepository;
    private readonly IServiceReminderRepository _serviceReminderRepository;
    private readonly IAppLogger<CompleteWorkOrderCommandHandler> _logger;
    private readonly IMapper _mapper;

    public CompleteWorkOrderCommandHandler(IWorkOrderRepository workOrderRepository, IMaintenanceHistoryRepository maintenanceHistoryRepository, IInventoryRepository inventoryRepository, IInventoryTransactionRepository inventoryTransactionRepository, IServiceReminderRepository serviceReminderRepository, IAppLogger<CompleteWorkOrderCommandHandler> logger, IMapper mapper)
    {
        _workOrderRepository = workOrderRepository;
        _maintenanceHistoryRepository = maintenanceHistoryRepository;
        _inventoryRepository = inventoryRepository;
        _inventoryTransactionRepository = inventoryTransactionRepository;
        _serviceReminderRepository = serviceReminderRepository;
        _logger = logger;
        _mapper = mapper;
    }

    public async Task<int> Handle(CompleteWorkOrderCommand request, CancellationToken cancellationToken)
    {
        // check if the work order exists
        var workOrder = await _workOrderRepository.GetWorkOrderWithDetailsAsync(request.ID);
        if (workOrder == null)
        {
            _logger.LogError($"Work order with ID {request.ID} not found.");
            throw new EntityNotFoundException(typeof(WorkOrder).ToString(), "WorkOrderID", request.ID.ToString());
        }

        // check if the work order is already completed
        if (workOrder.Status == WorkOrderStatusEnum.COMPLETED)
        {
            _logger.LogWarning($"Work order with ID {request.ID} is already completed.");
            throw new WorkOrderAlreadyCompletedException(request.ID);
        }

        // check if required fields are filled
        if (workOrder.IsReadyForCompletion() == false)
        {
            _logger.LogWarning($"Work order with ID {request.ID} is not ready for completion.");
            throw new IncompleteWorkOrderException(request.ID);
        }

        // reduce the item quantity in stock
        var itemsMap = workOrder.WorkOrderLineItems
            .Where(li => li.ItemType == LineItemTypeEnum.ITEM)
            .Select(li => new { li.InventoryItemID, li.Quantity })
            .ToList();

        // check if inventory has enough stock for each item and reduce stock
        foreach (var item in itemsMap)
        {
            if (item.InventoryItemID.HasValue)
            {
                var inventory = await _inventoryRepository.GetInventoryByItemIDAsync(item.InventoryItemID.Value);
                if (inventory == null || inventory.QuantityOnHand < item.Quantity)
                {
                    _logger.LogError($"Not enough stock for inventory item ID {item.InventoryItemID}.");
                    throw new InsufficientStockException(item.InventoryItemID.Value, item.Quantity);
                }

                // reduce the stock
                inventory.QuantityOnHand -= item.Quantity;
                _inventoryRepository.Update(inventory);

                // create transaction history
                var transaction = new InventoryTransaction
                {
                    ID = 0, // ID will be generated by the database
                    CreatedAt = DateTime.UtcNow,
                    UpdatedAt = DateTime.UtcNow,
                    InventoryID = inventory.ID,
                    TransactionType = TransactionTypeEnum.OUT,
                    Quantity = item.Quantity,
                    PerformedByUserID = workOrder.AssignedToUserID,
                    UnitCost = inventory.UnitCost,
                    TotalCost = inventory.UnitCost * item.Quantity,
                    Inventory = null!,
                    User = null!
                };

                // create inventory transaction
                await _inventoryTransactionRepository.AddAsync(transaction);
            }
        }

        // update the work order status to completed
        workOrder.Status = WorkOrderStatusEnum.COMPLETED;
        _workOrderRepository.Update(workOrder);

        // Make related serviceReminder status to be complete
        var serviceReminders = await _serviceReminderRepository.GetServiceRemindersByWorkOrderIdAsync(workOrder.ID);
        foreach (var serviceReminder in serviceReminders)
        {
            serviceReminder.Status = ServiceReminderStatusEnum.COMPLETED;
            _serviceReminderRepository.Update(serviceReminder);
        }

        await _serviceReminderRepository.SaveChangesAsync();

        // create a maintenance history entry
        var maintenanceHistory = _mapper.Map<MaintenanceHistory>(workOrder);
        await _maintenanceHistoryRepository.AddAsync(maintenanceHistory);

        await _maintenanceHistoryRepository.SaveChangesAsync();

        // return the updated work order id
        return workOrder.ID;
    }
}